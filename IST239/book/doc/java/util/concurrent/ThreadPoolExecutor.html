<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><!--JBuilder QuickDoc-->
<HEAD>
<TITLE>Class java.util.concurrent.ThreadPoolExecutor</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY>

<H2>
<FONT SIZE="-1">java.util.concurrent</FONT>
<BR>Class ThreadPoolExecutor</H2>
<DL>
<DT>public class <B>ThreadPoolExecutor</B><DT>extends java.util.concurrent.AbstractExecutorService
</DL>
<DL><DD>An <A HREF="ExecutorService">ExecutorService</A> that executes each submitted task using one of possibly several pooled threads, normally configured using <A HREF="Executors">Executors</A> factory methods. <p>Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each <tt>ThreadPoolExecutor</tt> also maintains some basic statistics, such as the number of completed tasks. <p>To be useful across a wide range of contexts, this class provides many adjustable parameters and extensibility hooks. However, programmers are urged to use the more convenient <A HREF="Executors">Executors</A> factory methods <A HREF="Executors#newCachedThreadPool">Executors#newCachedThreadPool</A> (unbounded thread pool, with automatic thread reclamation), <A HREF="Executors#newFixedThreadPool">Executors#newFixedThreadPool</A> (fixed size thread pool) and <A HREF="Executors#newSingleThreadExecutor">Executors#newSingleThreadExecutor</A> (single background thread), that preconfigure settings for the most common usage scenarios. Otherwise, use the following guide when manually configuring and tuning this class: <dl> <dt>Core and maximum pool sizes</dt> <dd>A <tt>ThreadPoolExecutor</tt> will automatically adjust the pool size (see <A HREF="ThreadPoolExecutor#getPoolSize">ThreadPoolExecutor#getPoolSize</A>) according to the bounds set by corePoolSize (see <A HREF="ThreadPoolExecutor#getCorePoolSize">ThreadPoolExecutor#getCorePoolSize</A>) and maximumPoolSize (see <A HREF="ThreadPoolExecutor#getMaximumPoolSize">ThreadPoolExecutor#getMaximumPoolSize</A>). When a new task is submitted in method <A HREF="ThreadPoolExecutor#execute">ThreadPoolExecutor#execute</A>, and fewer than corePoolSize threads are running, a new thread is created to handle the request, even if other worker threads are idle. If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full. By setting corePoolSize and maximumPoolSize the same, you create a fixed-size thread pool. By setting maximumPoolSize to an essentially unbounded value such as <tt>Integer.MAX_VALUE</tt>, you allow the pool to accommodate an arbitrary number of concurrent tasks. Most typically, core and maximum pool sizes are set only upon construction, but they may also be changed dynamically using <A HREF="ThreadPoolExecutor#setCorePoolSize">ThreadPoolExecutor#setCorePoolSize</A> and <A HREF="ThreadPoolExecutor#setMaximumPoolSize">ThreadPoolExecutor#setMaximumPoolSize</A>. <dd> <dt> On-demand construction <dd> By default, even core threads are initially created and started only when needed by new tasks, but this can be overridden dynamically using method <A HREF="ThreadPoolExecutor#prestartCoreThread">ThreadPoolExecutor#prestartCoreThread</A> or <A HREF="ThreadPoolExecutor#prestartAllCoreThreads">ThreadPoolExecutor#prestartAllCoreThreads</A>. </dd> <dt>Creating new threads</dt> <dd>New threads are created using a <A HREF="java.util.concurrent.ThreadFactory">java.util.concurrent.ThreadFactory</A>. If not otherwise specified, a <A HREF="Executors#defaultThreadFactory">Executors#defaultThreadFactory</A> is used, that creates threads to all be in the same <A HREF="ThreadGroup">ThreadGroup</A> and with the same <tt>NORM_PRIORITY</tt> priority and non-daemon status. By supplying a different ThreadFactory, you can alter the thread's name, thread group, priority, daemon status, etc. If a <tt>ThreadFactory</tt> fails to create a thread when asked by returning null from <tt>newThread</tt>, the executor will continue, but might not be able to execute any tasks. </dd> <dt>Keep-alive times</dt> <dd>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see <A HREF="ThreadPoolExecutor#getKeepAliveTime">ThreadPoolExecutor#getKeepAliveTime</A>). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method <A HREF="ThreadPoolExecutor#setKeepAliveTime">ThreadPoolExecutor#setKeepAliveTime</A>. Using a value of <tt>Long.MAX_VALUE</tt> <A HREF="TimeUnit#NANOSECONDS">TimeUnit#NANOSECONDS</A> effectively disables idle threads from ever terminating prior to shut down. </dd> <dt>Queuing</dt> <dd>Any <A HREF="BlockingQueue">BlockingQueue</A> may be used to transfer and hold submitted tasks. The use of this queue interacts with pool sizing: <ul> <li> If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.</li> <li> If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.</li> <li> If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.</li> </ul> There are three general strategies for queuing: <ol> <li> <em> Direct handoffs.</em> A good default choice for a work queue is a <A HREF="SynchronousQueue">SynchronousQueue</A> that hands off tasks to threads without otherwise holding them. Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed. This policy avoids lockups when handling sets of requests that might have internal dependencies. Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks. This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed. </li> <li><em> Unbounded queues.</em> Using an unbounded queue (for example a <A HREF="LinkedBlockingQueue">LinkedBlockingQueue</A> without a predefined capacity) will cause new tasks to be queued in cases where all corePoolSize threads are busy. Thus, no more than corePoolSize threads will ever be created. (And the value of the maximumPoolSize therefore doesn't have any effect.) This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server. While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed. </li> <li><em>Bounded queues.</em> A bounded queue (for example, an <A HREF="ArrayBlockingQueue">ArrayBlockingQueue</A>) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control. Queue sizes and maximum pool sizes may be traded off for each other: Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput. If tasks frequently block (for example if they are I/O bound), a system may be able to schedule time for more threads than you otherwise allow. Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput. </li> </ol> </dd> <dt>Rejected tasks</dt> <dd> New tasks submitted in method <A HREF="ThreadPoolExecutor#execute">ThreadPoolExecutor#execute</A> will be <em>rejected</em> when the Executor has been shut down, and also when the Executor uses finite bounds for both maximum threads and work queue capacity, and is saturated. In either case, the <tt>execute</tt> method invokes the <A HREF="RejectedExecutionHandler#rejectedExecution">RejectedExecutionHandler#rejectedExecution</A> method of its <A HREF="RejectedExecutionHandler">RejectedExecutionHandler</A>. Four predefined handler policies are provided: <ol> <li> In the default <A HREF="ThreadPoolExecutor.AbortPolicy">ThreadPoolExecutor.AbortPolicy</A>, the handler throws a runtime <A HREF="RejectedExecutionException">RejectedExecutionException</A> upon rejection. </li> <li> In <A HREF="ThreadPoolExecutor.CallerRunsPolicy">ThreadPoolExecutor.CallerRunsPolicy</A>, the thread that invokes <tt>execute</tt> itself runs the task. This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted. </li> <li> In <A HREF="ThreadPoolExecutor.DiscardPolicy">ThreadPoolExecutor.DiscardPolicy</A>, a task that cannot be executed is simply dropped. </li> <li>In <A HREF="ThreadPoolExecutor.DiscardOldestPolicy">ThreadPoolExecutor.DiscardOldestPolicy</A>, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.) </li> </ol> It is possible to define and use other kinds of <A HREF="RejectedExecutionHandler">RejectedExecutionHandler</A> classes. Doing so requires some care especially when policies are designed to work only under particular capacity or queuing policies. </dd> <dt>Hook methods</dt> <dd>This class provides <tt>protected</tt> overridable <A HREF="ThreadPoolExecutor#beforeExecute">ThreadPoolExecutor#beforeExecute</A> and <A HREF="ThreadPoolExecutor#afterExecute">ThreadPoolExecutor#afterExecute</A> methods that are called before and after execution of each task. These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries. Additionally, method <A HREF="ThreadPoolExecutor#terminated">ThreadPoolExecutor#terminated</A> can be overridden to perform any special processing that needs to be done once the Executor has fully terminated. <p>If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate.</dd> <dt>Queue maintenance</dt> <dd> Method <A HREF="ThreadPoolExecutor#getQueue">ThreadPoolExecutor#getQueue</A> allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, <A HREF="ThreadPoolExecutor#remove">ThreadPoolExecutor#remove</A> and <A HREF="ThreadPoolExecutor#purge">ThreadPoolExecutor#purge</A> are available to assist in storage reclamation when large numbers of queued tasks become cancelled.</dd> </dl> <p> <b>Extension example</b>. Most extensions of this class override one or more of the protected hook methods. For example, here is a subclass that adds a simple pause/resume feature: <pre>
class PausableThreadPoolExecutor extends ThreadPoolExecutor {
private boolean isPaused;
private ReentrantLock pauseLock = new ReentrantLock();
private Condition unpaused = pauseLock.newCondition();
public PausableThreadPoolExecutor(...) { super(...); }
protected void beforeExecute(Thread t, Runnable r) {
super.beforeExecute(t, r);
pauseLock.lock();
try {
while (isPaused) unpaused.await();
} catch(InterruptedException ie) {
t.interrupt();
} finally {
pauseLock.unlock();
}
}
public void pause() {
pauseLock.lock();
try {
isPaused = true;
} finally {
pauseLock.unlock();
}
}
public void resume() {
pauseLock.lock();
try {
isPaused = false;
unpaused.signalAll();
} finally {
pauseLock.unlock();
}
}
}
</pre><DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Author:</B><DD>Doug Lea</DD>
<DT><B>Since:</B><DD>1.5</DD>
</DL>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="EMPTY_RUNNABLE_ARRAY"></A>

<H3>EMPTY_RUNNABLE_ARRAY</H3>
<PRE>
private static final java.lang.Runnable[] <B>EMPTY_RUNNABLE_ARRAY</B></PRE>
<DL><DD>Only used to force toArray() to produce a Runnable[].<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="shutdownPerm"></A>

<H3>shutdownPerm</H3>
<PRE>
private static final java.lang.RuntimePermission <B>shutdownPerm</B></PRE>
<DL><DD>Permission for checking shutdown<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="workQueue"></A>

<H3>workQueue</H3>
<PRE>
private final java.util.concurrent.BlockingQueue<java.lang.Runnable> <B>workQueue</B></PRE>
<DL><DD>Queue used for holding tasks and handing off to worker threads.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="mainLock"></A>

<H3>mainLock</H3>
<PRE>
private final java.util.concurrent.locks.ReentrantLock <B>mainLock</B></PRE>
<DL><DD>Lock held on updates to poolSize, corePoolSize, maximumPoolSize, and workers set.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="termination"></A>

<H3>termination</H3>
<PRE>
private final java.util.concurrent.locks.Condition <B>termination</B></PRE>
<DL><DD>Wait condition to support awaitTermination<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="workers"></A>

<H3>workers</H3>
<PRE>
private final java.util.HashSet<java.util.concurrent.ThreadPoolExecutor.Worker> <B>workers</B></PRE>
<DL><DD>Set containing all worker threads in pool.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="keepAliveTime"></A>

<H3>keepAliveTime</H3>
<PRE>
private volatile long <B>keepAliveTime</B></PRE>
<DL><DD>Timeout in nanoseconds for idle threads waiting for work. Threads use this timeout only when there are more than corePoolSize present. Otherwise they wait forever for new work.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="corePoolSize"></A>

<H3>corePoolSize</H3>
<PRE>
private volatile int <B>corePoolSize</B></PRE>
<DL><DD>Core pool size, updated only while holding mainLock, but volatile to allow concurrent readability even during updates.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="maximumPoolSize"></A>

<H3>maximumPoolSize</H3>
<PRE>
private volatile int <B>maximumPoolSize</B></PRE>
<DL><DD>Maximum pool size, updated only while holding mainLock but volatile to allow concurrent readability even during updates.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="poolSize"></A>

<H3>poolSize</H3>
<PRE>
private volatile int <B>poolSize</B></PRE>
<DL><DD>Current pool size, updated only while holding mainLock but volatile to allow concurrent readability even during updates.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="runState"></A>

<H3>runState</H3>
<PRE>
volatile int <B>runState</B></PRE>
<DL><DD>Lifecycle state<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="RUNNING"></A>

<H3>RUNNING</H3>
<PRE>
static final int <B>RUNNING</B></PRE>
<DL><DD>Normal, not-shutdown mode<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="SHUTDOWN"></A>

<H3>SHUTDOWN</H3>
<PRE>
static final int <B>SHUTDOWN</B></PRE>
<DL><DD>Controlled shutdown mode<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="STOP"></A>

<H3>STOP</H3>
<PRE>
static final int <B>STOP</B></PRE>
<DL><DD>Immediate shutdown mode<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="TERMINATED"></A>

<H3>TERMINATED</H3>
<PRE>
static final int <B>TERMINATED</B></PRE>
<DL><DD>Final state<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="handler"></A>

<H3>handler</H3>
<PRE>
private volatile java.util.concurrent.RejectedExecutionHandler <B>handler</B></PRE>
<DL><DD>Handler called when saturated or shutdown in execute.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="threadFactory"></A>

<H3>threadFactory</H3>
<PRE>
private volatile java.util.concurrent.ThreadFactory <B>threadFactory</B></PRE>
<DL><DD>Factory for new threads.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="largestPoolSize"></A>

<H3>largestPoolSize</H3>
<PRE>
private int <B>largestPoolSize</B></PRE>
<DL><DD>Tracks largest attained pool size.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="completedTaskCount"></A>

<H3>completedTaskCount</H3>
<PRE>
private long <B>completedTaskCount</B></PRE>
<DL><DD>Counter for completed tasks. Updated only on termination of worker threads.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="defaultHandler"></A>

<H3>defaultHandler</H3>
<PRE>
private static final java.util.concurrent.RejectedExecutionHandler <B>defaultHandler</B></PRE>
<DL><DD>The default rejected execution handler<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)"></A>

<H3>ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          java.util.concurrent.TimeUnit&nbsp;unit,
                          java.util.concurrent.BlockingQueue&nbsp;workQueue)</PRE>
<DL><DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial parameters and default thread factory and handler. It may be more convenient to use one of the <A HREF="Executors">Executors</A> factory methods instead of this general purpose constructor.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the pool, even if they are idle.</DD>
<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the pool.</DD>
<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</DD>
<DD><CODE>unit</CODE> - the time unit for the keepAliveTime argument.</DD>
<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they are executed. This queue will hold only the <tt>Runnable</tt> tasks submitted by the <tt>execute</tt> method.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if corePoolSize, or keepAliveTime less than zero, or if maximumPoolSize less than or equal to zero, or if corePoolSize greater than maximumPoolSize.</DD>
<DD><CODE>NullPointerException</CODE> - if <tt>workQueue</tt> is null</DD>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)"></A>

<H3>ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          java.util.concurrent.TimeUnit&nbsp;unit,
                          java.util.concurrent.BlockingQueue&nbsp;workQueue,
                          java.util.concurrent.ThreadFactory&nbsp;threadFactory)</PRE>
<DL><DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial parameters.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the pool, even if they are idle.</DD>
<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the pool.</DD>
<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</DD>
<DD><CODE>unit</CODE> - the time unit for the keepAliveTime argument.</DD>
<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they are executed. This queue will hold only the <tt>Runnable</tt> tasks submitted by the <tt>execute</tt> method.</DD>
<DD><CODE>threadFactory</CODE> - the factory to use when the executor creates a new thread.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if corePoolSize, or keepAliveTime less than zero, or if maximumPoolSize less than or equal to zero, or if corePoolSize greater than maximumPoolSize.</DD>
<DD><CODE>NullPointerException</CODE> - if <tt>workQueue</tt> or <tt>threadFactory</tt> are null.</DD>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)"></A>

<H3>ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          java.util.concurrent.TimeUnit&nbsp;unit,
                          java.util.concurrent.BlockingQueue&nbsp;workQueue,
                          java.util.concurrent.RejectedExecutionHandler&nbsp;handler)</PRE>
<DL><DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial parameters.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the pool, even if they are idle.</DD>
<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the pool.</DD>
<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</DD>
<DD><CODE>unit</CODE> - the time unit for the keepAliveTime argument.</DD>
<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they are executed. This queue will hold only the <tt>Runnable</tt> tasks submitted by the <tt>execute</tt> method.</DD>
<DD><CODE>handler</CODE> - the handler to use when execution is blocked because the thread bounds and queue capacities are reached.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if corePoolSize, or keepAliveTime less than zero, or if maximumPoolSize less than or equal to zero, or if corePoolSize greater than maximumPoolSize.</DD>
<DD><CODE>NullPointerException</CODE> - if <tt>workQueue</tt> or <tt>handler</tt> are null.</DD>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)"></A>

<H3>ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          java.util.concurrent.TimeUnit&nbsp;unit,
                          java.util.concurrent.BlockingQueue&nbsp;workQueue,
                          java.util.concurrent.ThreadFactory&nbsp;threadFactory,
                          java.util.concurrent.RejectedExecutionHandler&nbsp;handler)</PRE>
<DL><DD>Creates a new <tt>ThreadPoolExecutor</tt> with the given initial parameters.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the number of threads to keep in the pool, even if they are idle.</DD>
<DD><CODE>maximumPoolSize</CODE> - the maximum number of threads to allow in the pool.</DD>
<DD><CODE>keepAliveTime</CODE> - when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</DD>
<DD><CODE>unit</CODE> - the time unit for the keepAliveTime argument.</DD>
<DD><CODE>workQueue</CODE> - the queue to use for holding tasks before they are executed. This queue will hold only the <tt>Runnable</tt> tasks submitted by the <tt>execute</tt> method.</DD>
<DD><CODE>threadFactory</CODE> - the factory to use when the executor creates a new thread.</DD>
<DD><CODE>handler</CODE> - the handler to use when execution is blocked because the thread bounds and queue capacities are reached.</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if corePoolSize, or keepAliveTime less than zero, or if maximumPoolSize less than or equal to zero, or if corePoolSize greater than maximumPoolSize.</DD>
<DD><CODE>NullPointerException</CODE> - if <tt>workQueue</tt> or <tt>threadFactory</tt> or <tt>handler</tt> are null.</DD>
</DL>
<HR>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B>
</FONT></TD></TR></TABLE>

<A NAME="reject(java.lang.Runnable)"></A>

<H3>reject</H3>
<PRE>
void <B>reject</B>(java.lang.Runnable&nbsp;command)</PRE>
<DL><DD>Invoke the rejected execution handler for the given command.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="addThread(java.lang.Runnable)"></A>

<H3>addThread</H3>
<PRE>
private java.lang.Thread <B>addThread</B>(java.lang.Runnable&nbsp;firstTask)</PRE>
<DL><DD>Create and return a new thread running firstTask as its first task. Call only while holding mainLock<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>firstTask</CODE> - the task the new thread should run first (or null if none)</DD>
<DT><B>Returns:</B><DD>the new thread, or null if threadFactory fails to create thread</DD>
</DL>
<HR>

<A NAME="addIfUnderCorePoolSize(java.lang.Runnable)"></A>

<H3>addIfUnderCorePoolSize</H3>
<PRE>
private boolean <B>addIfUnderCorePoolSize</B>(java.lang.Runnable&nbsp;firstTask)</PRE>
<DL><DD>Create and start a new thread running firstTask as its first task, only if fewer than corePoolSize threads are running.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>firstTask</CODE> - the task the new thread should run first (or null if none)</DD>
<DT><B>Returns:</B><DD>true if successful.</DD>
</DL>
<HR>

<A NAME="addIfUnderMaximumPoolSize(java.lang.Runnable)"></A>

<H3>addIfUnderMaximumPoolSize</H3>
<PRE>
private java.lang.Runnable <B>addIfUnderMaximumPoolSize</B>(java.lang.Runnable&nbsp;firstTask)</PRE>
<DL><DD>Create and start a new thread only if fewer than maximumPoolSize threads are running. The new thread runs as its first task the next task in queue, or if there is none, the given task.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>firstTask</CODE> - the task the new thread should run first (or null if none)</DD>
<DT><B>Returns:</B><DD>null on failure, else the first task to be run by new thread.</DD>
</DL>
<HR>

<A NAME="getTask()"></A>

<H3>getTask</H3>
<PRE>
java.lang.Runnable <B>getTask</B>()</PRE>
<DL><DD>Get the next task for a worker thread to run.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the task</DD>
<DT><B>Throws:</B><DD><CODE>InterruptedException</CODE> - if interrupted while waiting for task</DD>
</DL>
<HR>

<A NAME="interruptIdleWorkers()"></A>

<H3>interruptIdleWorkers</H3>
<PRE>
void <B>interruptIdleWorkers</B>()</PRE>
<DL><DD>Wake up all threads that might be waiting for tasks.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="workerDone(java.util.concurrent.ThreadPoolExecutor$Worker)"></A>

<H3>workerDone</H3>
<PRE>
void <B>workerDone</B>(java.util.concurrent.ThreadPoolExecutor$Worker&nbsp;w)</PRE>
<DL><DD>Perform bookkeeping for a terminated worker thread.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>w</CODE> - the worker</DD>
</DL>
<HR>

<A NAME="execute(java.lang.Runnable)"></A>

<H3>execute</H3>
<PRE>
public void <B>execute</B>(java.lang.Runnable&nbsp;command)</PRE>
<DL><DD>Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current <tt>RejectedExecutionHandler</tt>.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>command</CODE> - the task to execute</DD>
<DT><B>Throws:</B><DD><CODE>RejectedExecutionException</CODE> - at discretion of <tt>RejectedExecutionHandler</tt>, if task cannot be accepted for execution</DD>
<DD><CODE>NullPointerException</CODE> - if command is null</DD>
</DL>
<HR>

<A NAME="shutdown()"></A>

<H3>shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL><DD>Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Throws:</B><DD><CODE>SecurityException</CODE> - if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold <A HREF="java.lang.RuntimePermission">java.lang.RuntimePermission</A><tt>("modifyThread")</tt>, or the security manager's <tt>checkAccess</tt> method denies access.</DD>
</DL>
<HR>

<A NAME="shutdownNow()"></A>

<H3>shutdownNow</H3>
<PRE>
public java.util.List <B>shutdownNow</B>()</PRE>
<DL><DD>Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. <p>This implementation cancels tasks via <A HREF="Thread#interrupt">Thread#interrupt</A>, so if any tasks mask or fail to respond to interrupts, they may never terminate.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>list of tasks that never commenced execution</DD>
<DT><B>Throws:</B><DD><CODE>SecurityException</CODE> - if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold <A HREF="java.lang.RuntimePermission">java.lang.RuntimePermission</A><tt>("modifyThread")</tt>, or the security manager's <tt>checkAccess</tt> method denies access.</DD>
</DL>
<HR>

<A NAME="isTerminating()"></A>

<H3>isTerminating</H3>
<PRE>
public boolean <B>isTerminating</B>()</PRE>
<DL><DD>Returns true if this executor is in the process of terminating after <tt>shutdown</tt> or <tt>shutdownNow</tt> but has not completely terminated. This method may be useful for debugging. A return of <tt>true</tt> reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if terminating but not yet terminated.</DD>
</DL>
<HR>

<A NAME="finalize()"></A>

<H3>finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL><DD>Invokes <tt>shutdown</tt> when this executor is no longer referenced.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="setThreadFactory(java.util.concurrent.ThreadFactory)"></A>

<H3>setThreadFactory</H3>
<PRE>
public void <B>setThreadFactory</B>(java.util.concurrent.ThreadFactory&nbsp;threadFactory)</PRE>
<DL><DD>Sets the thread factory used to create new threads.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>threadFactory</CODE> - the new thread factory</DD>
<DT><B>Throws:</B><DD><CODE>NullPointerException</CODE> - if threadFactory is null</DD>
<DT><B>See Also:</B><DD>#getThreadFactory</DD>
</DL>
<HR>

<A NAME="getThreadFactory()"></A>

<H3>getThreadFactory</H3>
<PRE>
public java.util.concurrent.ThreadFactory <B>getThreadFactory</B>()</PRE>
<DL><DD>Returns the thread factory used to create new threads.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the current thread factory</DD>
<DT><B>See Also:</B><DD>#setThreadFactory</DD>
</DL>
<HR>

<A NAME="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"></A>

<H3>setRejectedExecutionHandler</H3>
<PRE>
public void <B>setRejectedExecutionHandler</B>(java.util.concurrent.RejectedExecutionHandler&nbsp;handler)</PRE>
<DL><DD>Sets a new handler for unexecutable tasks.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>handler</CODE> - the new handler</DD>
<DT><B>Throws:</B><DD><CODE>NullPointerException</CODE> - if handler is null</DD>
<DT><B>See Also:</B><DD>#getRejectedExecutionHandler</DD>
</DL>
<HR>

<A NAME="getRejectedExecutionHandler()"></A>

<H3>getRejectedExecutionHandler</H3>
<PRE>
public java.util.concurrent.RejectedExecutionHandler <B>getRejectedExecutionHandler</B>()</PRE>
<DL><DD>Returns the current handler for unexecutable tasks.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the current handler</DD>
<DT><B>See Also:</B><DD>#setRejectedExecutionHandler</DD>
</DL>
<HR>

<A NAME="getQueue()"></A>

<H3>getQueue</H3>
<PRE>
public java.util.concurrent.BlockingQueue <B>getQueue</B>()</PRE>
<DL><DD>Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use. Retrieving the task queue does not prevent queued tasks from executing.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the task queue</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Runnable)"></A>

<H3>remove</H3>
<PRE>
public boolean <B>remove</B>(java.lang.Runnable&nbsp;task)</PRE>
<DL><DD>Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started. <p> This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using <tt>submit</tt> might be converted into a form that maintains <tt>Future</tt> status. However, in such cases, method <A HREF="ThreadPoolExecutor#purge">ThreadPoolExecutor#purge</A> may be used to remove those Futures that have been cancelled.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>task</CODE> - the task to remove</DD>
<DT><B>Returns:</B><DD>true if the task was removed</DD>
</DL>
<HR>

<A NAME="purge()"></A>

<H3>purge</H3>
<PRE>
public void <B>purge</B>()</PRE>
<DL><DD>Tries to remove from the work queue all <A HREF="Future">Future</A> tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

<A NAME="setCorePoolSize(int)"></A>

<H3>setCorePoolSize</H3>
<PRE>
public void <B>setCorePoolSize</B>(int&nbsp;corePoolSize)</PRE>
<DL><DD>Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>corePoolSize</CODE> - the new core size</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if <tt>corePoolSize</tt> less than zero</DD>
<DT><B>See Also:</B><DD>#getCorePoolSize</DD>
</DL>
<HR>

<A NAME="getCorePoolSize()"></A>

<H3>getCorePoolSize</H3>
<PRE>
public int <B>getCorePoolSize</B>()</PRE>
<DL><DD>Returns the core number of threads.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the core number of threads</DD>
<DT><B>See Also:</B><DD>#setCorePoolSize</DD>
</DL>
<HR>

<A NAME="prestartCoreThread()"></A>

<H3>prestartCoreThread</H3>
<PRE>
public boolean <B>prestartCoreThread</B>()</PRE>
<DL><DD>Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return <tt>false</tt> if all core threads have already been started.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>true if a thread was started</DD>
</DL>
<HR>

<A NAME="prestartAllCoreThreads()"></A>

<H3>prestartAllCoreThreads</H3>
<PRE>
public int <B>prestartAllCoreThreads</B>()</PRE>
<DL><DD>Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of threads started.</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"></A>

<H3>setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;maximumPoolSize)</PRE>
<DL><DD>Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>maximumPoolSize</CODE> - the new maximum</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if maximumPoolSize less than zero or the <A HREF="#getCorePoolSize core pool size">core pool size</A></DD>
<DT><B>See Also:</B><DD>#getMaximumPoolSize</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"></A>

<H3>getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL><DD>Returns the maximum allowed number of threads.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the maximum allowed number of threads</DD>
<DT><B>See Also:</B><DD>#setMaximumPoolSize</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long, java.util.concurrent.TimeUnit)"></A>

<H3>setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;time,
                             java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL><DD>Sets the time limit for which threads may remain idle before being terminated. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads will be terminated. This overrides any value set in the constructor.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>time</CODE> - the time to wait. A time value of zero will cause excess threads to terminate immediately after executing tasks.</DD>
<DD><CODE>unit</CODE> - the time unit of the time argument</DD>
<DT><B>Throws:</B><DD><CODE>IllegalArgumentException</CODE> - if time less than zero</DD>
<DT><B>See Also:</B><DD>#getKeepAliveTime</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime(java.util.concurrent.TimeUnit)"></A>

<H3>getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>(java.util.concurrent.TimeUnit&nbsp;unit)</PRE>
<DL><DD>Returns the thread keep-alive time, which is the amount of time which threads in excess of the core pool size may remain idle before being terminated.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>unit</CODE> - the desired time unit of the result</DD>
<DT><B>Returns:</B><DD>the time limit</DD>
<DT><B>See Also:</B><DD>#setKeepAliveTime</DD>
</DL>
<HR>

<A NAME="getPoolSize()"></A>

<H3>getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL><DD>Returns the current number of threads in the pool.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of threads</DD>
</DL>
<HR>

<A NAME="getActiveCount()"></A>

<H3>getActiveCount</H3>
<PRE>
public int <B>getActiveCount</B>()</PRE>
<DL><DD>Returns the approximate number of threads that are actively executing tasks.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of threads</DD>
</DL>
<HR>

<A NAME="getLargestPoolSize()"></A>

<H3>getLargestPoolSize</H3>
<PRE>
public int <B>getLargestPoolSize</B>()</PRE>
<DL><DD>Returns the largest number of threads that have ever simultaneously been in the pool.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of threads</DD>
</DL>
<HR>

<A NAME="getTaskCount()"></A>

<H3>getTaskCount</H3>
<PRE>
public long <B>getTaskCount</B>()</PRE>
<DL><DD>Returns the approximate total number of tasks that have been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of tasks</DD>
</DL>
<HR>

<A NAME="getCompletedTaskCount()"></A>

<H3>getCompletedTaskCount</H3>
<PRE>
public long <B>getCompletedTaskCount</B>()</PRE>
<DL><DD>Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Returns:</B><DD>the number of tasks</DD>
</DL>
<HR>

<A NAME="beforeExecute(java.lang.Thread, java.lang.Runnable)"></A>

<H3>beforeExecute</H3>
<PRE>
protected void <B>beforeExecute</B>(java.lang.Thread&nbsp;t,
                             java.lang.Runnable&nbsp;r)</PRE>
<DL><DD>Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread <tt>t</tt> that will execute task <tt>r</tt>, and may be used to re-initialize ThreadLocals, or to perform logging. Note: To properly nest multiple overridings, subclasses should generally invoke <tt>super.beforeExecute</tt> at the end of this method.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>t</CODE> - the thread that will run task r.</DD>
<DD><CODE>r</CODE> - the task that will be executed.</DD>
</DL>
<HR>

<A NAME="afterExecute(java.lang.Runnable, java.lang.Throwable)"></A>

<H3>afterExecute</H3>
<PRE>
protected void <B>afterExecute</B>(java.lang.Runnable&nbsp;r,
                            java.lang.Throwable&nbsp;t)</PRE>
<DL><DD>Method invoked upon completion of execution of the given Runnable. This method is invoked by the thread that executed the task. If non-null, the Throwable is the uncaught exception that caused execution to terminate abruptly. Note: To properly nest multiple overridings, subclasses should generally invoke <tt>super.afterExecute</tt> at the beginning of this method.<DL><DD></DD></DL></DD>
</DL>
<DL><DT><B>Parameters:</B><DD><CODE>r</CODE> - the runnable that has completed.</DD>
<DD><CODE>t</CODE> - the exception that caused termination, or null if execution completed normally.</DD>
</DL>
<HR>

<A NAME="terminated()"></A>

<H3>terminated</H3>
<PRE>
protected void <B>terminated</B>()</PRE>
<DL><DD>Method invoked when the Executor has terminated. Default implementation does nothing. Note: To properly nest multiple overridings, subclasses should generally invoke <tt>super.terminated</tt> within this method.<DL><DD></DD></DL></DD>
</DL>
<DL></DL>
<HR>

</BODY>
</HTML>